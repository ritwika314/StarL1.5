Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> pgm
Rule 1     pgm -> agentDecl mwblock decls initblock
Rule 2     agentDecl -> AGENT BR CID
Rule 3     initblock -> INIT LPAREN RPAREN LCURLY events RCURLY
Rule 4     events -> event events
Rule 5     events -> empty
Rule 6     event -> robotinit
Rule 7     event -> varname LPAREN RPAREN LCURLY pre eff RCURLY
Rule 8     event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY
Rule 9     robotinit -> ROBOT LPAREN RPAREN SEMI
Rule 10    pre -> PRE LPAREN cond RPAREN SEMI
Rule 11    pre -> PRE LPAREN TRUE RPAREN SEMI
Rule 12    cond -> rel
Rule 13    cond -> expr
Rule 14    cond -> cond AND cond
Rule 15    cond -> cond OR cond
Rule 16    cond -> NOT expr
Rule 17    cond -> LPAREN cond RPAREN
Rule 18    rel -> expr EQ expr
Rule 19    rel -> expr NEQ expr
Rule 20    rel -> expr GEQ expr
Rule 21    rel -> expr LEQ expr
Rule 22    rel -> expr GE expr
Rule 23    rel -> expr LE expr
Rule 24    eff -> EFF LCURLY stmts RCURLY
Rule 25    stmts -> stmt stmts
Rule 26    stmts -> empty
Rule 27    stmt -> asgn
Rule 28    stmt -> ite
Rule 29    stmt -> atomic
Rule 30    stmt -> funcCall
Rule 31    ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
Rule 32    funcCall -> varname LPAREN RPAREN SEMI
Rule 33    atomic -> ATOMIC LCURLY stmts RCURLY
Rule 34    asgn -> varname EQLS expr SEMI
Rule 35    asgn -> varname EQLS funcCall
Rule 36    asgn -> varname INCR SEMI
Rule 37    mwblock -> MW LCURLY decls RCURLY
Rule 38    decls -> decl decls
Rule 39    decls -> sharedecl decls
Rule 40    decls -> empty
Rule 41    empty -> <empty>
Rule 42    decl -> type varname SEMI
Rule 43    decl -> type varname EQLS val SEMI
Rule 44    sharedecl -> SHARED type varname SEMI
Rule 45    sharedecl -> SHARED type varname EQLS val SEMI
Rule 46    val -> INUM
Rule 47    val -> FNUM
Rule 48    val -> TRUE
Rule 49    val -> FALSE
Rule 50    expr -> val
Rule 51    expr -> varname
Rule 52    expr -> expr PLUS expr
Rule 53    expr -> expr MINUS expr
Rule 54    expr -> expr TIMES expr
Rule 55    expr -> expr BY expr
Rule 56    expr -> LPAREN expr RPAREN
Rule 57    type -> INT
Rule 58    type -> FLOAT
Rule 59    type -> BOOL
Rule 60    varname -> LID
Rule 61    varname -> CID

Terminals, with rules where they appear

AGENT                : 2
AND                  : 14
ATOMIC               : 33
BOOL                 : 59
BR                   : 2
BY                   : 55
CID                  : 2 61
EFF                  : 24
ELSE                 : 31
EQ                   : 18
EQLS                 : 34 35 43 45
EXIT                 : 8
FALSE                : 49
FLOAT                : 58
FNUM                 : 47
GE                   : 22
GEQ                  : 20
IF                   : 31
INCR                 : 36
INIT                 : 3
INT                  : 57
INUM                 : 46
LCURLY               : 3 7 8 24 31 31 33 37
LE                   : 23
LEQ                  : 21
LID                  : 60
LPAREN               : 3 7 8 9 10 11 17 31 32 56
MINUS                : 53
MW                   : 37
NEQ                  : 19
NOT                  : 16
OR                   : 15
PLUS                 : 52
PRE                  : 10 11
RCURLY               : 3 7 8 24 31 31 33 37
ROBOT                : 9
RPAREN               : 3 7 8 9 10 11 17 31 32 56
SEMI                 : 9 10 11 32 34 36 42 43 44 45
SHARED               : 44 45
TIMES                : 54
TRUE                 : 11 48
error                : 

Nonterminals, with rules where they appear

agentDecl            : 1
asgn                 : 27
atomic               : 29
cond                 : 10 14 14 15 15 17 31
decl                 : 38
decls                : 1 37 38 39
eff                  : 7 8
empty                : 5 26 40
event                : 4
events               : 3 4
expr                 : 13 16 18 18 19 19 20 20 21 21 22 22 23 23 34 52 52 53 53 54 54 55 55 56
funcCall             : 30 35
initblock            : 1
ite                  : 28
mwblock              : 1
pgm                  : 0
pre                  : 7 8
rel                  : 12
robotinit            : 6
sharedecl            : 39
stmt                 : 25
stmts                : 24 25 31 31 33
type                 : 42 43 44 45
val                  : 43 45 50
varname              : 7 32 34 35 36 42 43 44 45 51

Parsing method: LALR

state 0

    (0) S' -> . pgm
    (1) pgm -> . agentDecl mwblock decls initblock
    (2) agentDecl -> . AGENT BR CID

    AGENT           shift and go to state 2

    agentDecl                      shift and go to state 3
    pgm                            shift and go to state 1

state 1

    (0) S' -> pgm .



state 2

    (2) agentDecl -> AGENT . BR CID

    BR              shift and go to state 4


state 3

    (1) pgm -> agentDecl . mwblock decls initblock
    (37) mwblock -> . MW LCURLY decls RCURLY

    MW              shift and go to state 6

    mwblock                        shift and go to state 5

state 4

    (2) agentDecl -> AGENT BR . CID

    CID             shift and go to state 7


state 5

    (1) pgm -> agentDecl mwblock . decls initblock
    (38) decls -> . decl decls
    (39) decls -> . sharedecl decls
    (40) decls -> . empty
    (42) decl -> . type varname SEMI
    (43) decl -> . type varname EQLS val SEMI
    (44) sharedecl -> . SHARED type varname SEMI
    (45) sharedecl -> . SHARED type varname EQLS val SEMI
    (41) empty -> .
    (57) type -> . INT
    (58) type -> . FLOAT
    (59) type -> . BOOL

    SHARED          shift and go to state 12
    INIT            reduce using rule 41 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    BOOL            shift and go to state 11

    decl                           shift and go to state 8
    sharedecl                      shift and go to state 13
    decls                          shift and go to state 14
    type                           shift and go to state 15
    empty                          shift and go to state 16

state 6

    (37) mwblock -> MW . LCURLY decls RCURLY

    LCURLY          shift and go to state 17


state 7

    (2) agentDecl -> AGENT BR CID .

    MW              reduce using rule 2 (agentDecl -> AGENT BR CID .)


state 8

    (38) decls -> decl . decls
    (38) decls -> . decl decls
    (39) decls -> . sharedecl decls
    (40) decls -> . empty
    (42) decl -> . type varname SEMI
    (43) decl -> . type varname EQLS val SEMI
    (44) sharedecl -> . SHARED type varname SEMI
    (45) sharedecl -> . SHARED type varname EQLS val SEMI
    (41) empty -> .
    (57) type -> . INT
    (58) type -> . FLOAT
    (59) type -> . BOOL

    SHARED          shift and go to state 12
    INIT            reduce using rule 41 (empty -> .)
    RCURLY          reduce using rule 41 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    BOOL            shift and go to state 11

    decl                           shift and go to state 8
    sharedecl                      shift and go to state 13
    decls                          shift and go to state 18
    type                           shift and go to state 15
    empty                          shift and go to state 16

state 9

    (57) type -> INT .

    LID             reduce using rule 57 (type -> INT .)
    CID             reduce using rule 57 (type -> INT .)


state 10

    (58) type -> FLOAT .

    LID             reduce using rule 58 (type -> FLOAT .)
    CID             reduce using rule 58 (type -> FLOAT .)


state 11

    (59) type -> BOOL .

    LID             reduce using rule 59 (type -> BOOL .)
    CID             reduce using rule 59 (type -> BOOL .)


state 12

    (44) sharedecl -> SHARED . type varname SEMI
    (45) sharedecl -> SHARED . type varname EQLS val SEMI
    (57) type -> . INT
    (58) type -> . FLOAT
    (59) type -> . BOOL

    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    BOOL            shift and go to state 11

    type                           shift and go to state 19

state 13

    (39) decls -> sharedecl . decls
    (38) decls -> . decl decls
    (39) decls -> . sharedecl decls
    (40) decls -> . empty
    (42) decl -> . type varname SEMI
    (43) decl -> . type varname EQLS val SEMI
    (44) sharedecl -> . SHARED type varname SEMI
    (45) sharedecl -> . SHARED type varname EQLS val SEMI
    (41) empty -> .
    (57) type -> . INT
    (58) type -> . FLOAT
    (59) type -> . BOOL

    SHARED          shift and go to state 12
    INIT            reduce using rule 41 (empty -> .)
    RCURLY          reduce using rule 41 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    BOOL            shift and go to state 11

    decl                           shift and go to state 8
    sharedecl                      shift and go to state 13
    decls                          shift and go to state 20
    type                           shift and go to state 15
    empty                          shift and go to state 16

state 14

    (1) pgm -> agentDecl mwblock decls . initblock
    (3) initblock -> . INIT LPAREN RPAREN LCURLY events RCURLY

    INIT            shift and go to state 22

    initblock                      shift and go to state 21

state 15

    (42) decl -> type . varname SEMI
    (43) decl -> type . varname EQLS val SEMI
    (60) varname -> . LID
    (61) varname -> . CID

    LID             shift and go to state 23
    CID             shift and go to state 24

    varname                        shift and go to state 25

state 16

    (40) decls -> empty .

    INIT            reduce using rule 40 (decls -> empty .)
    RCURLY          reduce using rule 40 (decls -> empty .)


state 17

    (37) mwblock -> MW LCURLY . decls RCURLY
    (38) decls -> . decl decls
    (39) decls -> . sharedecl decls
    (40) decls -> . empty
    (42) decl -> . type varname SEMI
    (43) decl -> . type varname EQLS val SEMI
    (44) sharedecl -> . SHARED type varname SEMI
    (45) sharedecl -> . SHARED type varname EQLS val SEMI
    (41) empty -> .
    (57) type -> . INT
    (58) type -> . FLOAT
    (59) type -> . BOOL

    SHARED          shift and go to state 12
    RCURLY          reduce using rule 41 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    BOOL            shift and go to state 11

    decl                           shift and go to state 8
    sharedecl                      shift and go to state 13
    decls                          shift and go to state 26
    type                           shift and go to state 15
    empty                          shift and go to state 16

state 18

    (38) decls -> decl decls .

    INIT            reduce using rule 38 (decls -> decl decls .)
    RCURLY          reduce using rule 38 (decls -> decl decls .)


state 19

    (44) sharedecl -> SHARED type . varname SEMI
    (45) sharedecl -> SHARED type . varname EQLS val SEMI
    (60) varname -> . LID
    (61) varname -> . CID

    LID             shift and go to state 23
    CID             shift and go to state 24

    varname                        shift and go to state 27

state 20

    (39) decls -> sharedecl decls .

    INIT            reduce using rule 39 (decls -> sharedecl decls .)
    RCURLY          reduce using rule 39 (decls -> sharedecl decls .)


state 21

    (1) pgm -> agentDecl mwblock decls initblock .

    $end            reduce using rule 1 (pgm -> agentDecl mwblock decls initblock .)


state 22

    (3) initblock -> INIT . LPAREN RPAREN LCURLY events RCURLY

    LPAREN          shift and go to state 28


state 23

    (60) varname -> LID .

    LPAREN          reduce using rule 60 (varname -> LID .)
    PLUS            reduce using rule 60 (varname -> LID .)
    MINUS           reduce using rule 60 (varname -> LID .)
    TIMES           reduce using rule 60 (varname -> LID .)
    BY              reduce using rule 60 (varname -> LID .)
    EQ              reduce using rule 60 (varname -> LID .)
    NEQ             reduce using rule 60 (varname -> LID .)
    GEQ             reduce using rule 60 (varname -> LID .)
    LEQ             reduce using rule 60 (varname -> LID .)
    GE              reduce using rule 60 (varname -> LID .)
    LE              reduce using rule 60 (varname -> LID .)
    RPAREN          reduce using rule 60 (varname -> LID .)
    AND             reduce using rule 60 (varname -> LID .)
    OR              reduce using rule 60 (varname -> LID .)
    SEMI            reduce using rule 60 (varname -> LID .)
    EQLS            reduce using rule 60 (varname -> LID .)
    INCR            reduce using rule 60 (varname -> LID .)


state 24

    (61) varname -> CID .

    LPAREN          reduce using rule 61 (varname -> CID .)
    PLUS            reduce using rule 61 (varname -> CID .)
    MINUS           reduce using rule 61 (varname -> CID .)
    TIMES           reduce using rule 61 (varname -> CID .)
    BY              reduce using rule 61 (varname -> CID .)
    EQ              reduce using rule 61 (varname -> CID .)
    NEQ             reduce using rule 61 (varname -> CID .)
    GEQ             reduce using rule 61 (varname -> CID .)
    LEQ             reduce using rule 61 (varname -> CID .)
    GE              reduce using rule 61 (varname -> CID .)
    LE              reduce using rule 61 (varname -> CID .)
    RPAREN          reduce using rule 61 (varname -> CID .)
    AND             reduce using rule 61 (varname -> CID .)
    OR              reduce using rule 61 (varname -> CID .)
    SEMI            reduce using rule 61 (varname -> CID .)
    EQLS            reduce using rule 61 (varname -> CID .)
    INCR            reduce using rule 61 (varname -> CID .)


state 25

    (42) decl -> type varname . SEMI
    (43) decl -> type varname . EQLS val SEMI

    SEMI            shift and go to state 30
    EQLS            shift and go to state 29


state 26

    (37) mwblock -> MW LCURLY decls . RCURLY

    RCURLY          shift and go to state 31


state 27

    (44) sharedecl -> SHARED type varname . SEMI
    (45) sharedecl -> SHARED type varname . EQLS val SEMI

    SEMI            shift and go to state 32
    EQLS            shift and go to state 33


state 28

    (3) initblock -> INIT LPAREN . RPAREN LCURLY events RCURLY

    RPAREN          shift and go to state 34


state 29

    (43) decl -> type varname EQLS . val SEMI
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE

    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35

    val                            shift and go to state 36

state 30

    (42) decl -> type varname SEMI .

    SHARED          reduce using rule 42 (decl -> type varname SEMI .)
    INT             reduce using rule 42 (decl -> type varname SEMI .)
    FLOAT           reduce using rule 42 (decl -> type varname SEMI .)
    BOOL            reduce using rule 42 (decl -> type varname SEMI .)
    INIT            reduce using rule 42 (decl -> type varname SEMI .)
    RCURLY          reduce using rule 42 (decl -> type varname SEMI .)


state 31

    (37) mwblock -> MW LCURLY decls RCURLY .

    SHARED          reduce using rule 37 (mwblock -> MW LCURLY decls RCURLY .)
    INT             reduce using rule 37 (mwblock -> MW LCURLY decls RCURLY .)
    FLOAT           reduce using rule 37 (mwblock -> MW LCURLY decls RCURLY .)
    BOOL            reduce using rule 37 (mwblock -> MW LCURLY decls RCURLY .)
    INIT            reduce using rule 37 (mwblock -> MW LCURLY decls RCURLY .)


state 32

    (44) sharedecl -> SHARED type varname SEMI .

    SHARED          reduce using rule 44 (sharedecl -> SHARED type varname SEMI .)
    INT             reduce using rule 44 (sharedecl -> SHARED type varname SEMI .)
    FLOAT           reduce using rule 44 (sharedecl -> SHARED type varname SEMI .)
    BOOL            reduce using rule 44 (sharedecl -> SHARED type varname SEMI .)
    INIT            reduce using rule 44 (sharedecl -> SHARED type varname SEMI .)
    RCURLY          reduce using rule 44 (sharedecl -> SHARED type varname SEMI .)


state 33

    (45) sharedecl -> SHARED type varname EQLS . val SEMI
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE

    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35

    val                            shift and go to state 40

state 34

    (3) initblock -> INIT LPAREN RPAREN . LCURLY events RCURLY

    LCURLY          shift and go to state 41


state 35

    (49) val -> FALSE .

    PLUS            reduce using rule 49 (val -> FALSE .)
    MINUS           reduce using rule 49 (val -> FALSE .)
    TIMES           reduce using rule 49 (val -> FALSE .)
    BY              reduce using rule 49 (val -> FALSE .)
    RPAREN          reduce using rule 49 (val -> FALSE .)
    AND             reduce using rule 49 (val -> FALSE .)
    OR              reduce using rule 49 (val -> FALSE .)
    EQ              reduce using rule 49 (val -> FALSE .)
    NEQ             reduce using rule 49 (val -> FALSE .)
    GEQ             reduce using rule 49 (val -> FALSE .)
    LEQ             reduce using rule 49 (val -> FALSE .)
    GE              reduce using rule 49 (val -> FALSE .)
    LE              reduce using rule 49 (val -> FALSE .)
    SEMI            reduce using rule 49 (val -> FALSE .)


state 36

    (43) decl -> type varname EQLS val . SEMI

    SEMI            shift and go to state 42


state 37

    (47) val -> FNUM .

    PLUS            reduce using rule 47 (val -> FNUM .)
    MINUS           reduce using rule 47 (val -> FNUM .)
    TIMES           reduce using rule 47 (val -> FNUM .)
    BY              reduce using rule 47 (val -> FNUM .)
    RPAREN          reduce using rule 47 (val -> FNUM .)
    AND             reduce using rule 47 (val -> FNUM .)
    OR              reduce using rule 47 (val -> FNUM .)
    EQ              reduce using rule 47 (val -> FNUM .)
    NEQ             reduce using rule 47 (val -> FNUM .)
    GEQ             reduce using rule 47 (val -> FNUM .)
    LEQ             reduce using rule 47 (val -> FNUM .)
    GE              reduce using rule 47 (val -> FNUM .)
    LE              reduce using rule 47 (val -> FNUM .)
    SEMI            reduce using rule 47 (val -> FNUM .)


state 38

    (46) val -> INUM .

    PLUS            reduce using rule 46 (val -> INUM .)
    MINUS           reduce using rule 46 (val -> INUM .)
    TIMES           reduce using rule 46 (val -> INUM .)
    BY              reduce using rule 46 (val -> INUM .)
    RPAREN          reduce using rule 46 (val -> INUM .)
    AND             reduce using rule 46 (val -> INUM .)
    OR              reduce using rule 46 (val -> INUM .)
    EQ              reduce using rule 46 (val -> INUM .)
    NEQ             reduce using rule 46 (val -> INUM .)
    GEQ             reduce using rule 46 (val -> INUM .)
    LEQ             reduce using rule 46 (val -> INUM .)
    GE              reduce using rule 46 (val -> INUM .)
    LE              reduce using rule 46 (val -> INUM .)
    SEMI            reduce using rule 46 (val -> INUM .)


state 39

    (48) val -> TRUE .

    PLUS            reduce using rule 48 (val -> TRUE .)
    MINUS           reduce using rule 48 (val -> TRUE .)
    TIMES           reduce using rule 48 (val -> TRUE .)
    BY              reduce using rule 48 (val -> TRUE .)
    RPAREN          reduce using rule 48 (val -> TRUE .)
    AND             reduce using rule 48 (val -> TRUE .)
    OR              reduce using rule 48 (val -> TRUE .)
    EQ              reduce using rule 48 (val -> TRUE .)
    NEQ             reduce using rule 48 (val -> TRUE .)
    GEQ             reduce using rule 48 (val -> TRUE .)
    LEQ             reduce using rule 48 (val -> TRUE .)
    GE              reduce using rule 48 (val -> TRUE .)
    LE              reduce using rule 48 (val -> TRUE .)
    SEMI            reduce using rule 48 (val -> TRUE .)


state 40

    (45) sharedecl -> SHARED type varname EQLS val . SEMI

    SEMI            shift and go to state 43


state 41

    (3) initblock -> INIT LPAREN RPAREN LCURLY . events RCURLY
    (4) events -> . event events
    (5) events -> . empty
    (6) event -> . robotinit
    (7) event -> . varname LPAREN RPAREN LCURLY pre eff RCURLY
    (8) event -> . EXIT LPAREN RPAREN LCURLY pre eff RCURLY
    (41) empty -> .
    (9) robotinit -> . ROBOT LPAREN RPAREN SEMI
    (60) varname -> . LID
    (61) varname -> . CID

    EXIT            shift and go to state 48
    RCURLY          reduce using rule 41 (empty -> .)
    ROBOT           shift and go to state 46
    LID             shift and go to state 23
    CID             shift and go to state 24

    robotinit                      shift and go to state 45
    varname                        shift and go to state 44
    event                          shift and go to state 47
    events                         shift and go to state 49
    empty                          shift and go to state 50

state 42

    (43) decl -> type varname EQLS val SEMI .

    SHARED          reduce using rule 43 (decl -> type varname EQLS val SEMI .)
    INT             reduce using rule 43 (decl -> type varname EQLS val SEMI .)
    FLOAT           reduce using rule 43 (decl -> type varname EQLS val SEMI .)
    BOOL            reduce using rule 43 (decl -> type varname EQLS val SEMI .)
    INIT            reduce using rule 43 (decl -> type varname EQLS val SEMI .)
    RCURLY          reduce using rule 43 (decl -> type varname EQLS val SEMI .)


state 43

    (45) sharedecl -> SHARED type varname EQLS val SEMI .

    SHARED          reduce using rule 45 (sharedecl -> SHARED type varname EQLS val SEMI .)
    INT             reduce using rule 45 (sharedecl -> SHARED type varname EQLS val SEMI .)
    FLOAT           reduce using rule 45 (sharedecl -> SHARED type varname EQLS val SEMI .)
    BOOL            reduce using rule 45 (sharedecl -> SHARED type varname EQLS val SEMI .)
    INIT            reduce using rule 45 (sharedecl -> SHARED type varname EQLS val SEMI .)
    RCURLY          reduce using rule 45 (sharedecl -> SHARED type varname EQLS val SEMI .)


state 44

    (7) event -> varname . LPAREN RPAREN LCURLY pre eff RCURLY

    LPAREN          shift and go to state 51


state 45

    (6) event -> robotinit .

    EXIT            reduce using rule 6 (event -> robotinit .)
    ROBOT           reduce using rule 6 (event -> robotinit .)
    LID             reduce using rule 6 (event -> robotinit .)
    CID             reduce using rule 6 (event -> robotinit .)
    RCURLY          reduce using rule 6 (event -> robotinit .)


state 46

    (9) robotinit -> ROBOT . LPAREN RPAREN SEMI

    LPAREN          shift and go to state 52


state 47

    (4) events -> event . events
    (4) events -> . event events
    (5) events -> . empty
    (6) event -> . robotinit
    (7) event -> . varname LPAREN RPAREN LCURLY pre eff RCURLY
    (8) event -> . EXIT LPAREN RPAREN LCURLY pre eff RCURLY
    (41) empty -> .
    (9) robotinit -> . ROBOT LPAREN RPAREN SEMI
    (60) varname -> . LID
    (61) varname -> . CID

    EXIT            shift and go to state 48
    RCURLY          reduce using rule 41 (empty -> .)
    ROBOT           shift and go to state 46
    LID             shift and go to state 23
    CID             shift and go to state 24

    robotinit                      shift and go to state 45
    varname                        shift and go to state 44
    events                         shift and go to state 53
    event                          shift and go to state 47
    empty                          shift and go to state 50

state 48

    (8) event -> EXIT . LPAREN RPAREN LCURLY pre eff RCURLY

    LPAREN          shift and go to state 54


state 49

    (3) initblock -> INIT LPAREN RPAREN LCURLY events . RCURLY

    RCURLY          shift and go to state 55


state 50

    (5) events -> empty .

    RCURLY          reduce using rule 5 (events -> empty .)


state 51

    (7) event -> varname LPAREN . RPAREN LCURLY pre eff RCURLY

    RPAREN          shift and go to state 56


state 52

    (9) robotinit -> ROBOT LPAREN . RPAREN SEMI

    RPAREN          shift and go to state 57


state 53

    (4) events -> event events .

    RCURLY          reduce using rule 4 (events -> event events .)


state 54

    (8) event -> EXIT LPAREN . RPAREN LCURLY pre eff RCURLY

    RPAREN          shift and go to state 58


state 55

    (3) initblock -> INIT LPAREN RPAREN LCURLY events RCURLY .

    $end            reduce using rule 3 (initblock -> INIT LPAREN RPAREN LCURLY events RCURLY .)


state 56

    (7) event -> varname LPAREN RPAREN . LCURLY pre eff RCURLY

    LCURLY          shift and go to state 59


state 57

    (9) robotinit -> ROBOT LPAREN RPAREN . SEMI

    SEMI            shift and go to state 60


state 58

    (8) event -> EXIT LPAREN RPAREN . LCURLY pre eff RCURLY

    LCURLY          shift and go to state 61


state 59

    (7) event -> varname LPAREN RPAREN LCURLY . pre eff RCURLY
    (10) pre -> . PRE LPAREN cond RPAREN SEMI
    (11) pre -> . PRE LPAREN TRUE RPAREN SEMI

    PRE             shift and go to state 63

    pre                            shift and go to state 62

state 60

    (9) robotinit -> ROBOT LPAREN RPAREN SEMI .

    EXIT            reduce using rule 9 (robotinit -> ROBOT LPAREN RPAREN SEMI .)
    ROBOT           reduce using rule 9 (robotinit -> ROBOT LPAREN RPAREN SEMI .)
    LID             reduce using rule 9 (robotinit -> ROBOT LPAREN RPAREN SEMI .)
    CID             reduce using rule 9 (robotinit -> ROBOT LPAREN RPAREN SEMI .)
    RCURLY          reduce using rule 9 (robotinit -> ROBOT LPAREN RPAREN SEMI .)


state 61

    (8) event -> EXIT LPAREN RPAREN LCURLY . pre eff RCURLY
    (10) pre -> . PRE LPAREN cond RPAREN SEMI
    (11) pre -> . PRE LPAREN TRUE RPAREN SEMI

    PRE             shift and go to state 63

    pre                            shift and go to state 64

state 62

    (7) event -> varname LPAREN RPAREN LCURLY pre . eff RCURLY
    (24) eff -> . EFF LCURLY stmts RCURLY

    EFF             shift and go to state 65

    eff                            shift and go to state 66

state 63

    (10) pre -> PRE . LPAREN cond RPAREN SEMI
    (11) pre -> PRE . LPAREN TRUE RPAREN SEMI

    LPAREN          shift and go to state 67


state 64

    (8) event -> EXIT LPAREN RPAREN LCURLY pre . eff RCURLY
    (24) eff -> . EFF LCURLY stmts RCURLY

    EFF             shift and go to state 65

    eff                            shift and go to state 68

state 65

    (24) eff -> EFF . LCURLY stmts RCURLY

    LCURLY          shift and go to state 69


state 66

    (7) event -> varname LPAREN RPAREN LCURLY pre eff . RCURLY

    RCURLY          shift and go to state 70


state 67

    (10) pre -> PRE LPAREN . cond RPAREN SEMI
    (11) pre -> PRE LPAREN . TRUE RPAREN SEMI
    (12) cond -> . rel
    (13) cond -> . expr
    (14) cond -> . cond AND cond
    (15) cond -> . cond OR cond
    (16) cond -> . NOT expr
    (17) cond -> . LPAREN cond RPAREN
    (18) rel -> . expr EQ expr
    (19) rel -> . expr NEQ expr
    (20) rel -> . expr GEQ expr
    (21) rel -> . expr LEQ expr
    (22) rel -> . expr GE expr
    (23) rel -> . expr LE expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    TRUE            shift and go to state 72
    NOT             shift and go to state 78
    LPAREN          shift and go to state 74
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 76
    cond                           shift and go to state 71
    val                            shift and go to state 75
    rel                            shift and go to state 73
    varname                        shift and go to state 77

state 68

    (8) event -> EXIT LPAREN RPAREN LCURLY pre eff . RCURLY

    RCURLY          shift and go to state 79


state 69

    (24) eff -> EFF LCURLY . stmts RCURLY
    (25) stmts -> . stmt stmts
    (26) stmts -> . empty
    (27) stmt -> . asgn
    (28) stmt -> . ite
    (29) stmt -> . atomic
    (30) stmt -> . funcCall
    (41) empty -> .
    (34) asgn -> . varname EQLS expr SEMI
    (35) asgn -> . varname EQLS funcCall
    (36) asgn -> . varname INCR SEMI
    (31) ite -> . IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (33) atomic -> . ATOMIC LCURLY stmts RCURLY
    (32) funcCall -> . varname LPAREN RPAREN SEMI
    (60) varname -> . LID
    (61) varname -> . CID

    RCURLY          reduce using rule 41 (empty -> .)
    IF              shift and go to state 86
    ATOMIC          shift and go to state 81
    LID             shift and go to state 23
    CID             shift and go to state 24

    funcCall                       shift and go to state 87
    stmts                          shift and go to state 82
    varname                        shift and go to state 88
    ite                            shift and go to state 80
    stmt                           shift and go to state 85
    asgn                           shift and go to state 83
    atomic                         shift and go to state 89
    empty                          shift and go to state 84

state 70

    (7) event -> varname LPAREN RPAREN LCURLY pre eff RCURLY .

    EXIT            reduce using rule 7 (event -> varname LPAREN RPAREN LCURLY pre eff RCURLY .)
    ROBOT           reduce using rule 7 (event -> varname LPAREN RPAREN LCURLY pre eff RCURLY .)
    LID             reduce using rule 7 (event -> varname LPAREN RPAREN LCURLY pre eff RCURLY .)
    CID             reduce using rule 7 (event -> varname LPAREN RPAREN LCURLY pre eff RCURLY .)
    RCURLY          reduce using rule 7 (event -> varname LPAREN RPAREN LCURLY pre eff RCURLY .)


state 71

    (10) pre -> PRE LPAREN cond . RPAREN SEMI
    (14) cond -> cond . AND cond
    (15) cond -> cond . OR cond

    RPAREN          shift and go to state 91
    AND             shift and go to state 90
    OR              shift and go to state 92


state 72

    (11) pre -> PRE LPAREN TRUE . RPAREN SEMI
    (48) val -> TRUE .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 93
    EQ              reduce using rule 48 (val -> TRUE .)
    NEQ             reduce using rule 48 (val -> TRUE .)
    GEQ             reduce using rule 48 (val -> TRUE .)
    LEQ             reduce using rule 48 (val -> TRUE .)
    GE              reduce using rule 48 (val -> TRUE .)
    LE              reduce using rule 48 (val -> TRUE .)
    PLUS            reduce using rule 48 (val -> TRUE .)
    MINUS           reduce using rule 48 (val -> TRUE .)
    TIMES           reduce using rule 48 (val -> TRUE .)
    BY              reduce using rule 48 (val -> TRUE .)
    AND             reduce using rule 48 (val -> TRUE .)
    OR              reduce using rule 48 (val -> TRUE .)

  ! RPAREN          [ reduce using rule 48 (val -> TRUE .) ]


state 73

    (12) cond -> rel .

    RPAREN          reduce using rule 12 (cond -> rel .)
    AND             reduce using rule 12 (cond -> rel .)
    OR              reduce using rule 12 (cond -> rel .)


state 74

    (17) cond -> LPAREN . cond RPAREN
    (56) expr -> LPAREN . expr RPAREN
    (12) cond -> . rel
    (13) cond -> . expr
    (14) cond -> . cond AND cond
    (15) cond -> . cond OR cond
    (16) cond -> . NOT expr
    (17) cond -> . LPAREN cond RPAREN
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (18) rel -> . expr EQ expr
    (19) rel -> . expr NEQ expr
    (20) rel -> . expr GEQ expr
    (21) rel -> . expr LEQ expr
    (22) rel -> . expr GE expr
    (23) rel -> . expr LE expr
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    NOT             shift and go to state 78
    LPAREN          shift and go to state 74
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 95
    cond                           shift and go to state 94
    val                            shift and go to state 75
    rel                            shift and go to state 73
    varname                        shift and go to state 77

state 75

    (50) expr -> val .

    EQ              reduce using rule 50 (expr -> val .)
    NEQ             reduce using rule 50 (expr -> val .)
    GEQ             reduce using rule 50 (expr -> val .)
    LEQ             reduce using rule 50 (expr -> val .)
    GE              reduce using rule 50 (expr -> val .)
    LE              reduce using rule 50 (expr -> val .)
    PLUS            reduce using rule 50 (expr -> val .)
    MINUS           reduce using rule 50 (expr -> val .)
    TIMES           reduce using rule 50 (expr -> val .)
    BY              reduce using rule 50 (expr -> val .)
    AND             reduce using rule 50 (expr -> val .)
    OR              reduce using rule 50 (expr -> val .)
    RPAREN          reduce using rule 50 (expr -> val .)
    SEMI            reduce using rule 50 (expr -> val .)


state 76

    (13) cond -> expr .
    (18) rel -> expr . EQ expr
    (19) rel -> expr . NEQ expr
    (20) rel -> expr . GEQ expr
    (21) rel -> expr . LEQ expr
    (22) rel -> expr . GE expr
    (23) rel -> expr . LE expr
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    AND             reduce using rule 13 (cond -> expr .)
    OR              reduce using rule 13 (cond -> expr .)
    RPAREN          reduce using rule 13 (cond -> expr .)
    EQ              shift and go to state 103
    NEQ             shift and go to state 105
    GEQ             shift and go to state 96
    LEQ             shift and go to state 100
    GE              shift and go to state 101
    LE              shift and go to state 97
    PLUS            shift and go to state 102
    MINUS           shift and go to state 104
    TIMES           shift and go to state 99
    BY              shift and go to state 98


state 77

    (51) expr -> varname .

    EQ              reduce using rule 51 (expr -> varname .)
    NEQ             reduce using rule 51 (expr -> varname .)
    GEQ             reduce using rule 51 (expr -> varname .)
    LEQ             reduce using rule 51 (expr -> varname .)
    GE              reduce using rule 51 (expr -> varname .)
    LE              reduce using rule 51 (expr -> varname .)
    PLUS            reduce using rule 51 (expr -> varname .)
    MINUS           reduce using rule 51 (expr -> varname .)
    TIMES           reduce using rule 51 (expr -> varname .)
    BY              reduce using rule 51 (expr -> varname .)
    AND             reduce using rule 51 (expr -> varname .)
    OR              reduce using rule 51 (expr -> varname .)
    RPAREN          reduce using rule 51 (expr -> varname .)
    SEMI            reduce using rule 51 (expr -> varname .)


state 78

    (16) cond -> NOT . expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 106
    val                            shift and go to state 75
    varname                        shift and go to state 77

state 79

    (8) event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY .

    EXIT            reduce using rule 8 (event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY .)
    ROBOT           reduce using rule 8 (event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY .)
    LID             reduce using rule 8 (event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY .)
    CID             reduce using rule 8 (event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY .)
    RCURLY          reduce using rule 8 (event -> EXIT LPAREN RPAREN LCURLY pre eff RCURLY .)


state 80

    (28) stmt -> ite .

    IF              reduce using rule 28 (stmt -> ite .)
    ATOMIC          reduce using rule 28 (stmt -> ite .)
    LID             reduce using rule 28 (stmt -> ite .)
    CID             reduce using rule 28 (stmt -> ite .)
    RCURLY          reduce using rule 28 (stmt -> ite .)


state 81

    (33) atomic -> ATOMIC . LCURLY stmts RCURLY

    LCURLY          shift and go to state 108


state 82

    (24) eff -> EFF LCURLY stmts . RCURLY

    RCURLY          shift and go to state 109


state 83

    (27) stmt -> asgn .

    IF              reduce using rule 27 (stmt -> asgn .)
    ATOMIC          reduce using rule 27 (stmt -> asgn .)
    LID             reduce using rule 27 (stmt -> asgn .)
    CID             reduce using rule 27 (stmt -> asgn .)
    RCURLY          reduce using rule 27 (stmt -> asgn .)


state 84

    (26) stmts -> empty .

    RCURLY          reduce using rule 26 (stmts -> empty .)


state 85

    (25) stmts -> stmt . stmts
    (25) stmts -> . stmt stmts
    (26) stmts -> . empty
    (27) stmt -> . asgn
    (28) stmt -> . ite
    (29) stmt -> . atomic
    (30) stmt -> . funcCall
    (41) empty -> .
    (34) asgn -> . varname EQLS expr SEMI
    (35) asgn -> . varname EQLS funcCall
    (36) asgn -> . varname INCR SEMI
    (31) ite -> . IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (33) atomic -> . ATOMIC LCURLY stmts RCURLY
    (32) funcCall -> . varname LPAREN RPAREN SEMI
    (60) varname -> . LID
    (61) varname -> . CID

    RCURLY          reduce using rule 41 (empty -> .)
    IF              shift and go to state 86
    ATOMIC          shift and go to state 81
    LID             shift and go to state 23
    CID             shift and go to state 24

    funcCall                       shift and go to state 87
    stmts                          shift and go to state 110
    varname                        shift and go to state 88
    ite                            shift and go to state 80
    stmt                           shift and go to state 85
    asgn                           shift and go to state 83
    atomic                         shift and go to state 89
    empty                          shift and go to state 84

state 86

    (31) ite -> IF . LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY

    LPAREN          shift and go to state 111


state 87

    (30) stmt -> funcCall .

    IF              reduce using rule 30 (stmt -> funcCall .)
    ATOMIC          reduce using rule 30 (stmt -> funcCall .)
    LID             reduce using rule 30 (stmt -> funcCall .)
    CID             reduce using rule 30 (stmt -> funcCall .)
    RCURLY          reduce using rule 30 (stmt -> funcCall .)


state 88

    (34) asgn -> varname . EQLS expr SEMI
    (35) asgn -> varname . EQLS funcCall
    (36) asgn -> varname . INCR SEMI
    (32) funcCall -> varname . LPAREN RPAREN SEMI

    EQLS            shift and go to state 113
    INCR            shift and go to state 112
    LPAREN          shift and go to state 114


state 89

    (29) stmt -> atomic .

    IF              reduce using rule 29 (stmt -> atomic .)
    ATOMIC          reduce using rule 29 (stmt -> atomic .)
    LID             reduce using rule 29 (stmt -> atomic .)
    CID             reduce using rule 29 (stmt -> atomic .)
    RCURLY          reduce using rule 29 (stmt -> atomic .)


state 90

    (14) cond -> cond AND . cond
    (12) cond -> . rel
    (13) cond -> . expr
    (14) cond -> . cond AND cond
    (15) cond -> . cond OR cond
    (16) cond -> . NOT expr
    (17) cond -> . LPAREN cond RPAREN
    (18) rel -> . expr EQ expr
    (19) rel -> . expr NEQ expr
    (20) rel -> . expr GEQ expr
    (21) rel -> . expr LEQ expr
    (22) rel -> . expr GE expr
    (23) rel -> . expr LE expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    NOT             shift and go to state 78
    LPAREN          shift and go to state 74
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 76
    cond                           shift and go to state 115
    val                            shift and go to state 75
    rel                            shift and go to state 73
    varname                        shift and go to state 77

state 91

    (10) pre -> PRE LPAREN cond RPAREN . SEMI

    SEMI            shift and go to state 116


state 92

    (15) cond -> cond OR . cond
    (12) cond -> . rel
    (13) cond -> . expr
    (14) cond -> . cond AND cond
    (15) cond -> . cond OR cond
    (16) cond -> . NOT expr
    (17) cond -> . LPAREN cond RPAREN
    (18) rel -> . expr EQ expr
    (19) rel -> . expr NEQ expr
    (20) rel -> . expr GEQ expr
    (21) rel -> . expr LEQ expr
    (22) rel -> . expr GE expr
    (23) rel -> . expr LE expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    NOT             shift and go to state 78
    LPAREN          shift and go to state 74
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 76
    cond                           shift and go to state 117
    val                            shift and go to state 75
    rel                            shift and go to state 73
    varname                        shift and go to state 77

state 93

    (11) pre -> PRE LPAREN TRUE RPAREN . SEMI

    SEMI            shift and go to state 118


state 94

    (17) cond -> LPAREN cond . RPAREN
    (14) cond -> cond . AND cond
    (15) cond -> cond . OR cond

    RPAREN          shift and go to state 119
    AND             shift and go to state 90
    OR              shift and go to state 92


state 95

    (56) expr -> LPAREN expr . RPAREN
    (13) cond -> expr .
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr
    (18) rel -> expr . EQ expr
    (19) rel -> expr . NEQ expr
    (20) rel -> expr . GEQ expr
    (21) rel -> expr . LEQ expr
    (22) rel -> expr . GE expr
    (23) rel -> expr . LE expr

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 120
    AND             reduce using rule 13 (cond -> expr .)
    OR              reduce using rule 13 (cond -> expr .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 104
    TIMES           shift and go to state 99
    BY              shift and go to state 98
    EQ              shift and go to state 103
    NEQ             shift and go to state 105
    GEQ             shift and go to state 96
    LEQ             shift and go to state 100
    GE              shift and go to state 101
    LE              shift and go to state 97

  ! RPAREN          [ reduce using rule 13 (cond -> expr .) ]


state 96

    (20) rel -> expr GEQ . expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 121
    val                            shift and go to state 75
    varname                        shift and go to state 77

state 97

    (23) rel -> expr LE . expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 122
    val                            shift and go to state 75
    varname                        shift and go to state 77

state 98

    (55) expr -> expr BY . expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 123
    val                            shift and go to state 75
    varname                        shift and go to state 77

state 99

    (54) expr -> expr TIMES . expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 124
    val                            shift and go to state 75
    varname                        shift and go to state 77

state 100

    (21) rel -> expr LEQ . expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 125
    val                            shift and go to state 75
    varname                        shift and go to state 77

state 101

    (22) rel -> expr GE . expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 126
    val                            shift and go to state 75
    varname                        shift and go to state 77

state 102

    (52) expr -> expr PLUS . expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 127
    val                            shift and go to state 75
    varname                        shift and go to state 77

state 103

    (18) rel -> expr EQ . expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 128
    val                            shift and go to state 75
    varname                        shift and go to state 77

state 104

    (53) expr -> expr MINUS . expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 129
    val                            shift and go to state 75
    varname                        shift and go to state 77

state 105

    (19) rel -> expr NEQ . expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 130
    val                            shift and go to state 75
    varname                        shift and go to state 77

state 106

    (16) cond -> NOT expr .
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    RPAREN          reduce using rule 16 (cond -> NOT expr .)
    AND             reduce using rule 16 (cond -> NOT expr .)
    OR              reduce using rule 16 (cond -> NOT expr .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 104
    TIMES           shift and go to state 99
    BY              shift and go to state 98


state 107

    (56) expr -> LPAREN . expr RPAREN
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    expr                           shift and go to state 131
    val                            shift and go to state 75
    varname                        shift and go to state 77

state 108

    (33) atomic -> ATOMIC LCURLY . stmts RCURLY
    (25) stmts -> . stmt stmts
    (26) stmts -> . empty
    (27) stmt -> . asgn
    (28) stmt -> . ite
    (29) stmt -> . atomic
    (30) stmt -> . funcCall
    (41) empty -> .
    (34) asgn -> . varname EQLS expr SEMI
    (35) asgn -> . varname EQLS funcCall
    (36) asgn -> . varname INCR SEMI
    (31) ite -> . IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (33) atomic -> . ATOMIC LCURLY stmts RCURLY
    (32) funcCall -> . varname LPAREN RPAREN SEMI
    (60) varname -> . LID
    (61) varname -> . CID

    RCURLY          reduce using rule 41 (empty -> .)
    IF              shift and go to state 86
    ATOMIC          shift and go to state 81
    LID             shift and go to state 23
    CID             shift and go to state 24

    funcCall                       shift and go to state 87
    stmts                          shift and go to state 132
    varname                        shift and go to state 88
    ite                            shift and go to state 80
    stmt                           shift and go to state 85
    asgn                           shift and go to state 83
    atomic                         shift and go to state 89
    empty                          shift and go to state 84

state 109

    (24) eff -> EFF LCURLY stmts RCURLY .

    RCURLY          reduce using rule 24 (eff -> EFF LCURLY stmts RCURLY .)


state 110

    (25) stmts -> stmt stmts .

    RCURLY          reduce using rule 25 (stmts -> stmt stmts .)


state 111

    (31) ite -> IF LPAREN . cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (12) cond -> . rel
    (13) cond -> . expr
    (14) cond -> . cond AND cond
    (15) cond -> . cond OR cond
    (16) cond -> . NOT expr
    (17) cond -> . LPAREN cond RPAREN
    (18) rel -> . expr EQ expr
    (19) rel -> . expr NEQ expr
    (20) rel -> . expr GEQ expr
    (21) rel -> . expr LEQ expr
    (22) rel -> . expr GE expr
    (23) rel -> . expr LE expr
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    NOT             shift and go to state 78
    LPAREN          shift and go to state 74
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    val                            shift and go to state 75
    expr                           shift and go to state 76
    cond                           shift and go to state 133
    rel                            shift and go to state 73
    varname                        shift and go to state 77

state 112

    (36) asgn -> varname INCR . SEMI

    SEMI            shift and go to state 134


state 113

    (34) asgn -> varname EQLS . expr SEMI
    (35) asgn -> varname EQLS . funcCall
    (50) expr -> . val
    (51) expr -> . varname
    (52) expr -> . expr PLUS expr
    (53) expr -> . expr MINUS expr
    (54) expr -> . expr TIMES expr
    (55) expr -> . expr BY expr
    (56) expr -> . LPAREN expr RPAREN
    (32) funcCall -> . varname LPAREN RPAREN SEMI
    (46) val -> . INUM
    (47) val -> . FNUM
    (48) val -> . TRUE
    (49) val -> . FALSE
    (60) varname -> . LID
    (61) varname -> . CID

    LPAREN          shift and go to state 107
    INUM            shift and go to state 38
    FNUM            shift and go to state 37
    TRUE            shift and go to state 39
    FALSE           shift and go to state 35
    LID             shift and go to state 23
    CID             shift and go to state 24

    varname                        shift and go to state 136
    val                            shift and go to state 75
    funcCall                       shift and go to state 135
    expr                           shift and go to state 137

state 114

    (32) funcCall -> varname LPAREN . RPAREN SEMI

    RPAREN          shift and go to state 138


state 115

    (14) cond -> cond AND cond .
    (14) cond -> cond . AND cond
    (15) cond -> cond . OR cond

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 14 (cond -> cond AND cond .)
    AND             shift and go to state 90
    OR              shift and go to state 92

  ! AND             [ reduce using rule 14 (cond -> cond AND cond .) ]
  ! OR              [ reduce using rule 14 (cond -> cond AND cond .) ]


state 116

    (10) pre -> PRE LPAREN cond RPAREN SEMI .

    EFF             reduce using rule 10 (pre -> PRE LPAREN cond RPAREN SEMI .)


state 117

    (15) cond -> cond OR cond .
    (14) cond -> cond . AND cond
    (15) cond -> cond . OR cond

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 15 (cond -> cond OR cond .)
    AND             shift and go to state 90
    OR              shift and go to state 92

  ! AND             [ reduce using rule 15 (cond -> cond OR cond .) ]
  ! OR              [ reduce using rule 15 (cond -> cond OR cond .) ]


state 118

    (11) pre -> PRE LPAREN TRUE RPAREN SEMI .

    EFF             reduce using rule 11 (pre -> PRE LPAREN TRUE RPAREN SEMI .)


state 119

    (17) cond -> LPAREN cond RPAREN .

    RPAREN          reduce using rule 17 (cond -> LPAREN cond RPAREN .)
    AND             reduce using rule 17 (cond -> LPAREN cond RPAREN .)
    OR              reduce using rule 17 (cond -> LPAREN cond RPAREN .)


state 120

    (56) expr -> LPAREN expr RPAREN .

    EQ              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    NEQ             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    GEQ             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LEQ             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    GE              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LE              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    BY              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    SEMI            reduce using rule 56 (expr -> LPAREN expr RPAREN .)


state 121

    (20) rel -> expr GEQ expr .
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    RPAREN          reduce using rule 20 (rel -> expr GEQ expr .)
    AND             reduce using rule 20 (rel -> expr GEQ expr .)
    OR              reduce using rule 20 (rel -> expr GEQ expr .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 104
    TIMES           shift and go to state 99
    BY              shift and go to state 98


state 122

    (23) rel -> expr LE expr .
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    RPAREN          reduce using rule 23 (rel -> expr LE expr .)
    AND             reduce using rule 23 (rel -> expr LE expr .)
    OR              reduce using rule 23 (rel -> expr LE expr .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 104
    TIMES           shift and go to state 99
    BY              shift and go to state 98


state 123

    (55) expr -> expr BY expr .
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    EQ              reduce using rule 55 (expr -> expr BY expr .)
    NEQ             reduce using rule 55 (expr -> expr BY expr .)
    GEQ             reduce using rule 55 (expr -> expr BY expr .)
    LEQ             reduce using rule 55 (expr -> expr BY expr .)
    GE              reduce using rule 55 (expr -> expr BY expr .)
    LE              reduce using rule 55 (expr -> expr BY expr .)
    PLUS            reduce using rule 55 (expr -> expr BY expr .)
    MINUS           reduce using rule 55 (expr -> expr BY expr .)
    TIMES           reduce using rule 55 (expr -> expr BY expr .)
    BY              reduce using rule 55 (expr -> expr BY expr .)
    AND             reduce using rule 55 (expr -> expr BY expr .)
    OR              reduce using rule 55 (expr -> expr BY expr .)
    RPAREN          reduce using rule 55 (expr -> expr BY expr .)
    SEMI            reduce using rule 55 (expr -> expr BY expr .)

  ! PLUS            [ shift and go to state 102 ]
  ! MINUS           [ shift and go to state 104 ]
  ! TIMES           [ shift and go to state 99 ]
  ! BY              [ shift and go to state 98 ]


state 124

    (54) expr -> expr TIMES expr .
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    EQ              reduce using rule 54 (expr -> expr TIMES expr .)
    NEQ             reduce using rule 54 (expr -> expr TIMES expr .)
    GEQ             reduce using rule 54 (expr -> expr TIMES expr .)
    LEQ             reduce using rule 54 (expr -> expr TIMES expr .)
    GE              reduce using rule 54 (expr -> expr TIMES expr .)
    LE              reduce using rule 54 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 54 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 54 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 54 (expr -> expr TIMES expr .)
    BY              reduce using rule 54 (expr -> expr TIMES expr .)
    AND             reduce using rule 54 (expr -> expr TIMES expr .)
    OR              reduce using rule 54 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 54 (expr -> expr TIMES expr .)
    SEMI            reduce using rule 54 (expr -> expr TIMES expr .)

  ! PLUS            [ shift and go to state 102 ]
  ! MINUS           [ shift and go to state 104 ]
  ! TIMES           [ shift and go to state 99 ]
  ! BY              [ shift and go to state 98 ]


state 125

    (21) rel -> expr LEQ expr .
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    RPAREN          reduce using rule 21 (rel -> expr LEQ expr .)
    AND             reduce using rule 21 (rel -> expr LEQ expr .)
    OR              reduce using rule 21 (rel -> expr LEQ expr .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 104
    TIMES           shift and go to state 99
    BY              shift and go to state 98


state 126

    (22) rel -> expr GE expr .
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    RPAREN          reduce using rule 22 (rel -> expr GE expr .)
    AND             reduce using rule 22 (rel -> expr GE expr .)
    OR              reduce using rule 22 (rel -> expr GE expr .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 104
    TIMES           shift and go to state 99
    BY              shift and go to state 98


state 127

    (52) expr -> expr PLUS expr .
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    EQ              reduce using rule 52 (expr -> expr PLUS expr .)
    NEQ             reduce using rule 52 (expr -> expr PLUS expr .)
    GEQ             reduce using rule 52 (expr -> expr PLUS expr .)
    LEQ             reduce using rule 52 (expr -> expr PLUS expr .)
    GE              reduce using rule 52 (expr -> expr PLUS expr .)
    LE              reduce using rule 52 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 52 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 52 (expr -> expr PLUS expr .)
    AND             reduce using rule 52 (expr -> expr PLUS expr .)
    OR              reduce using rule 52 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 52 (expr -> expr PLUS expr .)
    SEMI            reduce using rule 52 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 99
    BY              shift and go to state 98

  ! TIMES           [ reduce using rule 52 (expr -> expr PLUS expr .) ]
  ! BY              [ reduce using rule 52 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 102 ]
  ! MINUS           [ shift and go to state 104 ]


state 128

    (18) rel -> expr EQ expr .
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    RPAREN          reduce using rule 18 (rel -> expr EQ expr .)
    AND             reduce using rule 18 (rel -> expr EQ expr .)
    OR              reduce using rule 18 (rel -> expr EQ expr .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 104
    TIMES           shift and go to state 99
    BY              shift and go to state 98


state 129

    (53) expr -> expr MINUS expr .
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    EQ              reduce using rule 53 (expr -> expr MINUS expr .)
    NEQ             reduce using rule 53 (expr -> expr MINUS expr .)
    GEQ             reduce using rule 53 (expr -> expr MINUS expr .)
    LEQ             reduce using rule 53 (expr -> expr MINUS expr .)
    GE              reduce using rule 53 (expr -> expr MINUS expr .)
    LE              reduce using rule 53 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 53 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 53 (expr -> expr MINUS expr .)
    AND             reduce using rule 53 (expr -> expr MINUS expr .)
    OR              reduce using rule 53 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 53 (expr -> expr MINUS expr .)
    SEMI            reduce using rule 53 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 99
    BY              shift and go to state 98

  ! TIMES           [ reduce using rule 53 (expr -> expr MINUS expr .) ]
  ! BY              [ reduce using rule 53 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 102 ]
  ! MINUS           [ shift and go to state 104 ]


state 130

    (19) rel -> expr NEQ expr .
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    RPAREN          reduce using rule 19 (rel -> expr NEQ expr .)
    AND             reduce using rule 19 (rel -> expr NEQ expr .)
    OR              reduce using rule 19 (rel -> expr NEQ expr .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 104
    TIMES           shift and go to state 99
    BY              shift and go to state 98


state 131

    (56) expr -> LPAREN expr . RPAREN
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    RPAREN          shift and go to state 120
    PLUS            shift and go to state 102
    MINUS           shift and go to state 104
    TIMES           shift and go to state 99
    BY              shift and go to state 98


state 132

    (33) atomic -> ATOMIC LCURLY stmts . RCURLY

    RCURLY          shift and go to state 139


state 133

    (31) ite -> IF LPAREN cond . RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (14) cond -> cond . AND cond
    (15) cond -> cond . OR cond

    RPAREN          shift and go to state 140
    AND             shift and go to state 90
    OR              shift and go to state 92


state 134

    (36) asgn -> varname INCR SEMI .

    IF              reduce using rule 36 (asgn -> varname INCR SEMI .)
    ATOMIC          reduce using rule 36 (asgn -> varname INCR SEMI .)
    LID             reduce using rule 36 (asgn -> varname INCR SEMI .)
    CID             reduce using rule 36 (asgn -> varname INCR SEMI .)
    RCURLY          reduce using rule 36 (asgn -> varname INCR SEMI .)


state 135

    (35) asgn -> varname EQLS funcCall .

    IF              reduce using rule 35 (asgn -> varname EQLS funcCall .)
    ATOMIC          reduce using rule 35 (asgn -> varname EQLS funcCall .)
    LID             reduce using rule 35 (asgn -> varname EQLS funcCall .)
    CID             reduce using rule 35 (asgn -> varname EQLS funcCall .)
    RCURLY          reduce using rule 35 (asgn -> varname EQLS funcCall .)


state 136

    (51) expr -> varname .
    (32) funcCall -> varname . LPAREN RPAREN SEMI

    SEMI            reduce using rule 51 (expr -> varname .)
    PLUS            reduce using rule 51 (expr -> varname .)
    MINUS           reduce using rule 51 (expr -> varname .)
    TIMES           reduce using rule 51 (expr -> varname .)
    BY              reduce using rule 51 (expr -> varname .)
    LPAREN          shift and go to state 114


state 137

    (34) asgn -> varname EQLS expr . SEMI
    (52) expr -> expr . PLUS expr
    (53) expr -> expr . MINUS expr
    (54) expr -> expr . TIMES expr
    (55) expr -> expr . BY expr

    SEMI            shift and go to state 141
    PLUS            shift and go to state 102
    MINUS           shift and go to state 104
    TIMES           shift and go to state 99
    BY              shift and go to state 98


state 138

    (32) funcCall -> varname LPAREN RPAREN . SEMI

    SEMI            shift and go to state 142


state 139

    (33) atomic -> ATOMIC LCURLY stmts RCURLY .

    IF              reduce using rule 33 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    ATOMIC          reduce using rule 33 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    LID             reduce using rule 33 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    CID             reduce using rule 33 (atomic -> ATOMIC LCURLY stmts RCURLY .)
    RCURLY          reduce using rule 33 (atomic -> ATOMIC LCURLY stmts RCURLY .)


state 140

    (31) ite -> IF LPAREN cond RPAREN . LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY

    LCURLY          shift and go to state 143


state 141

    (34) asgn -> varname EQLS expr SEMI .

    IF              reduce using rule 34 (asgn -> varname EQLS expr SEMI .)
    ATOMIC          reduce using rule 34 (asgn -> varname EQLS expr SEMI .)
    LID             reduce using rule 34 (asgn -> varname EQLS expr SEMI .)
    CID             reduce using rule 34 (asgn -> varname EQLS expr SEMI .)
    RCURLY          reduce using rule 34 (asgn -> varname EQLS expr SEMI .)


state 142

    (32) funcCall -> varname LPAREN RPAREN SEMI .

    IF              reduce using rule 32 (funcCall -> varname LPAREN RPAREN SEMI .)
    ATOMIC          reduce using rule 32 (funcCall -> varname LPAREN RPAREN SEMI .)
    LID             reduce using rule 32 (funcCall -> varname LPAREN RPAREN SEMI .)
    CID             reduce using rule 32 (funcCall -> varname LPAREN RPAREN SEMI .)
    RCURLY          reduce using rule 32 (funcCall -> varname LPAREN RPAREN SEMI .)


state 143

    (31) ite -> IF LPAREN cond RPAREN LCURLY . stmts RCURLY ELSE LCURLY stmts RCURLY
    (25) stmts -> . stmt stmts
    (26) stmts -> . empty
    (27) stmt -> . asgn
    (28) stmt -> . ite
    (29) stmt -> . atomic
    (30) stmt -> . funcCall
    (41) empty -> .
    (34) asgn -> . varname EQLS expr SEMI
    (35) asgn -> . varname EQLS funcCall
    (36) asgn -> . varname INCR SEMI
    (31) ite -> . IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (33) atomic -> . ATOMIC LCURLY stmts RCURLY
    (32) funcCall -> . varname LPAREN RPAREN SEMI
    (60) varname -> . LID
    (61) varname -> . CID

    RCURLY          reduce using rule 41 (empty -> .)
    IF              shift and go to state 86
    ATOMIC          shift and go to state 81
    LID             shift and go to state 23
    CID             shift and go to state 24

    funcCall                       shift and go to state 87
    stmts                          shift and go to state 144
    varname                        shift and go to state 88
    ite                            shift and go to state 80
    stmt                           shift and go to state 85
    asgn                           shift and go to state 83
    atomic                         shift and go to state 89
    empty                          shift and go to state 84

state 144

    (31) ite -> IF LPAREN cond RPAREN LCURLY stmts . RCURLY ELSE LCURLY stmts RCURLY

    RCURLY          shift and go to state 145


state 145

    (31) ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY . ELSE LCURLY stmts RCURLY

    ELSE            shift and go to state 146


state 146

    (31) ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE . LCURLY stmts RCURLY

    LCURLY          shift and go to state 147


state 147

    (31) ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY . stmts RCURLY
    (25) stmts -> . stmt stmts
    (26) stmts -> . empty
    (27) stmt -> . asgn
    (28) stmt -> . ite
    (29) stmt -> . atomic
    (30) stmt -> . funcCall
    (41) empty -> .
    (34) asgn -> . varname EQLS expr SEMI
    (35) asgn -> . varname EQLS funcCall
    (36) asgn -> . varname INCR SEMI
    (31) ite -> . IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY
    (33) atomic -> . ATOMIC LCURLY stmts RCURLY
    (32) funcCall -> . varname LPAREN RPAREN SEMI
    (60) varname -> . LID
    (61) varname -> . CID

    RCURLY          reduce using rule 41 (empty -> .)
    IF              shift and go to state 86
    ATOMIC          shift and go to state 81
    LID             shift and go to state 23
    CID             shift and go to state 24

    funcCall                       shift and go to state 87
    stmts                          shift and go to state 148
    varname                        shift and go to state 88
    ite                            shift and go to state 80
    stmt                           shift and go to state 85
    asgn                           shift and go to state 83
    atomic                         shift and go to state 89
    empty                          shift and go to state 84

state 148

    (31) ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts . RCURLY

    RCURLY          shift and go to state 149


state 149

    (31) ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .

    IF              reduce using rule 31 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    ATOMIC          reduce using rule 31 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    LID             reduce using rule 31 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    CID             reduce using rule 31 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)
    RCURLY          reduce using rule 31 (ite -> IF LPAREN cond RPAREN LCURLY stmts RCURLY ELSE LCURLY stmts RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 72 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 95 resolved as shift
WARNING: shift/reduce conflict for AND in state 115 resolved as shift
WARNING: shift/reduce conflict for OR in state 115 resolved as shift
WARNING: shift/reduce conflict for AND in state 117 resolved as shift
WARNING: shift/reduce conflict for OR in state 117 resolved as shift
